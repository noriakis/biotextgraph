---
title: "wcGeneSummary"
author: "Noriaki Sato"
package: wcGeneSummary
output: 
    BiocStyle::html_document:
        toc_float: true
vignette: >
    %\VignetteIndexEntry{wcGeneSummary}
    %\VignetteEngine{knitr::knitr}
    %\VignetteEncoding{UTF-8}  
---

This package aims to visualize the word and text information contained in the gene or the other omics identifiers such as microbiome, and identify important words among the clusters, and compare the clusters based on those information. It contributes to understanding the gene clusters and aid in easy interpretation and visualization.

# Basic usage

Load the package and the database for converting identifiers.
In this example, we use mostly human-derived data, and use `org.Hs.eg.db`.

```{r load, warning=FALSE, message=FALSE}
library(wcGeneSummary)
library(org.Hs.eg.db)
library(ggplot2)
library(ggraph)
library(RColorBrewer)
library(ReactomePA)
library(clusterProfiler)
library(dendextend)
library(dplyr)
```

## Producing word clouds

We use ERCC genes as input. The basic usage of the package is producing a word cloud of gene summaries by querying gene IDs, default to symbol. The other type can be set by `keyType`. As many of the words are commonly observed, you should limit word frequency by `excludeFreq`, which is default to 2000. TF-IDF on the all the summary is precomputed, and `exclude="tfidf"` can be specified too.

```{r basic, warning=FALSE, message=FALSE, cache=TRUE, fig.height=8, fig.width=8}
## Configure input genes
inpSymbol <- c("ERCC1","ERCC2","ERCC3","ERCC4","ERCC5","ERCC6","ERCC8")
gwc <- wcGeneSummary(inpSymbol)
gwc@wc
```

It accepts values of the `wordcloud()` function. `numWords` specifies how many words are to be shown on word cloud. The words are ordered by their frequency, and the subset of 1:`numWords` is used to downstream visualization.

```{r basic2, warning=FALSE, message=FALSE, cache=TRUE, fig.height=8, fig.width=8}
## Use palette from palettetown, palettetown::pokepal(150) (Mewtwo!)
gwc <- wcGeneSummary(inpSymbol,
                     numWords=100,
                     excludeFreq=5000,
                     argList=list(
                      "random.order"=FALSE,
                     "colors"=palette(),
                     "rot.per"=0.4))
gwc@wc
```

By default, `preserve=TRUE`, which indicates the funciton tries to preserve the original cases of characters.

```{r basic_pres_false, warning=FALSE, message=FALSE, cache=TRUE, fig.height=8, fig.width=8}
gwc_p <- wcGeneSummary(inpSymbol, 
                     numWords=100,
                     excludeFreq=5000,
                     preserve=FALSE,
                     argList=list(
                       rot.per=0.4,
                       colors=RColorBrewer::brewer.pal(8, "Set2"),
                       random.order=FALSE
                     ))
gwc_p@wc
```

It also returns a data frame consisting of frequency of each term.

```{r table, cache=TRUE}
gwc
knitr::kable(
  head(gwc@freqDf), caption = 'Term frequencies.',
  row.names = FALSE
)
```

N-gram is supported by library `tm`, specified by `ngram`.
Default is `1`, and the example specifying `2` is shown below.

```{r ngramwc, warning=FALSE, fig.height=8, fig.width=8, cache=TRUE}
gwc2 <- wcGeneSummary(inpSymbol,
                      ngram=2,
                      numWords=50)
gwc2@wc
```

Using `clusterProfiler` functions, one can use enriched pathway names for visualization.
The `enrich` option can be specified for `'kegg'` or `'reactome'`, this time we specify `'reactome'`.

```{r ngrampath, warning=FALSE, fig.height=8, fig.width=8, cache=TRUE}
gwc3 <- wcGeneSummary(inpSymbol,
                      enrich="reactome", tfidf=TRUE, numWords=50)
gwc3@wc
```

One of the main questions is which words can be clustered together among the words contained in the queried gene cluster. Word clustering (`pvclust`) and identified significant clusters based on the occurrence in the text can be visualized by specifying `tag=TRUE`. For the significance threshold, `pvclAlpha` can be specified. The default parameters perform `pvclust` on the subset of dataset for words with high frequency specified by `numWords`. If one want to perform on whole matrix (which is a natural way), `tagWhole=TRUE` can be specified, although it is computationally intensive. One can pass clusters to perform parallel computing owning to `pvclust` function, by specifying `cl` as below.

```{r tagging, warning=FALSE, cache=TRUE, fig.height=8, fig.width=8}

pal <- RColorBrewer::brewer.pal(4, "PuOr") 
pal <- colorRampPalette(pal)(20)


## Cluster on subset of words
gwcl <- wcGeneSummary(inpSymbol,
                     numWords=30,
                     tag=TRUE,
                     pal = pal,
                     argList=list(rot.per=0.4))
gwcl@wc
gwcl@pvpick

## Cluster on whole matrix

gwclWhole <- wcGeneSummary(inpSymbol,
                     numWords=50,
                     tag=TRUE, tagWhole=TRUE,
                     pal = pal,
                     cl=snow::makeCluster(8),
                     argList=list(rot.per=0.4))
gwclWhole@wc
gwclWhole@pvpick
```

In this example showing ERCC genes, the term `DNA repair` is clustered as expected.

## Producing correlation networks

The next main function is producing correlation networks between words based on the co-occurrence of the words in the text.

```{r basic3, warning=FALSE, message=FALSE, cache=TRUE, fig.height=8, fig.width=8}
net <- wcGeneSummary(inpSymbol, plotType="network")
net@net
```

The edge label corresponding to correlation values can be shown by `edgeLabel=TRUE`. The number of words to be shown on plot can be specified by `numWords`. The threshold of correlation can be specified by `corThresh`. The text color can be changed by `colorText=TRUE`. The type of edge can be specified by `edgeLink`, which is by default `TRUE` (link will be used).

```{r ngramnet, warning=FALSE, message=FALSE, cache=T, fig.height=8, fig.width=8}
net <- wcGeneSummary(inpSymbol, plotType="network",
                     edgeLabel=TRUE, corThresh=0.5,
                     numWords=20, colorText=TRUE)
net@net
```

The clustering results based on `pvclust` can be shown also on the correlation network, by the node color (`tag=TRUE`). We can plot `igraph` object as well, using basic `plot` function implemented.

```{r tagnet, warning=FALSE, message=FALSE, cache=T, fig.height=8, fig.width=8}
net <- wcGeneSummary(inpSymbol, plotType="network", corThresh=0.2,
                     numWords=20, tag=TRUE)
net@net
net@pvpick
plot(net)
```

The genes associated with the corresponding words can be shown by specifying `genePlot=TRUE`, useful for assessing which words is associated with interesting genes. The edges connecting words to corresponding genes are shown.
Additionally, one can specify `genePlotNum` for limiting the genes shown, which can be useful for identifying important genes associated with high-frequent words.

```{r gplot, warning=FALSE, message=FALSE, cache=TRUE, fig.height=8, fig.width=8}
net <- wcGeneSummary(inpSymbol, plotType="network",
                     genePlot=TRUE, corThresh=0.5,
                     tag=TRUE, edgeLink=FALSE,
                     numWords=20)
net@net
```

The associated enriched pathways (if present) can be shown by specifying `genePathPlot`, using `ggforce`.
In this option, the function first performs over-representation analysis on the whole gene set, and plot enriched terms for included genes in the plot. Enrichment analysis here is performed by the library `clusterProfiler` or `ReactomePA`, and one can control which pathways to plot by `genePathPlotSig` value.

```{r gpplot, warning=FALSE, message=FALSE, cache=TRUE, fig.width=8, fig.height=8}
library(concaveman)
library(ggforce)
net <- wcGeneSummary(inpSymbol, plotType="network",
                     genePathPlot="reactome", corThresh=0.5,
                     tag=TRUE, edgeLink=FALSE,
                     genePathPlotSig=0.05, numWords=20)

net@net
```


## Visualization of PubMed information.

Using `rentrez`, one can perform the same analysis on PubMed text like the article title and abstract. The function queries for the input gene symbols (or microbes) and visualize. For typical use cases, the genes identified by showing `genePlot`, or hub genes identified in gene network analysis can be queried. The basic parameters for searching PubMed, like max number of articles retrieved and how to sort the articles can be specified by `retMax` and `sortOrder`. Be sure to obtain [an api key](https://ncbiinsights.ncbi.nlm.nih.gov/2017/11/02/new-api-keys-for-the-e-utilities/) when querying heavily, and specify in `apiKey` argument.
 
```{r wcabst_wc, cache=FALSE, fig.height=8, fig.width=8}
ab <- wcAbst(inpSymbol[1:3], retMax=20)
ab@wc
```

As fetching the same information is not desirable and time consuming, the same object can be passed to `redo` option and re-perform the analysis like tagging, or changing the visualization options.

```{r wcabst_wc_2, cache=TRUE, fig.height=8, fig.width=8}
pal <- brewer.pal(5, "PuOr") 
abtag <- wcAbst(redo=ab, tag=TRUE,
                cl=snow::makeCluster(10), pal=pal)
abtag2 <- wcAbst(redo=abtag, tag=TRUE, genePlot=TRUE,
                 plotType="network", corThresh=0.2, preset=TRUE)
abtag@wc
abtag2@net
```


## Comparing two or more networks

One can compare two or more networks by providing list of objects produced by wc* functions, like `wcGeneSummary` and `wcAbst`. This can be useful for assessing the similarity and dissimilarity of the various text sources, like PubMed, RefSeq, and Reactome pathway names.

```{r compare, cache=TRUE, fig.height=12, fig.width=12}
cxcls <- c()
for (i in c(1,2,3,5,6,8,9,10,11,12,13,14,16)){
    cxcls <- c(cxcls, paste0("CXCL",i))
}

net1 <- wcGeneSummary(inpSymbol, plotType="network",
                      corThresh=0.5, numWords=20)
net2 <- wcGeneSummary(cxcls, plotType="network",
                      corThresh=0.5, numWords=20)
net3 <- wcAbst(redo=ab, plotType="network",
               corThresh=0.2, numWords=20)

## Not having meaningful overlaps
compareWordNet(list(net1, net2),
               titles=c("ercc","cxcl"))
compareWordNet(list(net1, net3),
               titles=c("ercc","ercc-PubMed"))
compareWordNet(list(net1, net2, net3),
               titles=c("ercc","cxcl", "ercc-PubMed"))
```

If `tag` information is available in both gene clusters, combined tags can be visualized by `tag=TRUE`.

```{r tagcomp, cache=TRUE, fig.height=12, fig.width=15}
keggPathways <- org.Hs.egPATH2EG
mappedKeys <- mappedkeys(keggPathways)
keggList <- as.list(keggPathways[mappedKeys])

net1 <- wcGeneSummary(keggList$`04110`,
                      keyType="ENTREZID",
                      plotType="network",
                      corThresh=0.3,
                      numWords=30,
                      tag=TRUE,
                      tfidf=TRUE)

net2 <- wcGeneSummary(keggList$`04210`,
                      keyType="ENTREZID",
                      plotType="network",
                      corThresh=0.3,
                      numWords=30,
                      tfidf=TRUE,
                      tag=TRUE)

compareWordNet(list(net1, net2), tag=TRUE)
```

## Query words across clusters

## Text over represenatation analysis (experimental)

```{r ora, fig.width=5, fig.height=5}
geneList <- keggList$`00785` # Lipoic acid metabolism
pvs <- textORA(geneList)
hist(pvs)
pvs[order(pvs)] |> head()

geneList <- keggList$`05150` # Staphylococcus aureus infection
pvs <- textORA(geneList)
hist(pvs)
pvs[order(pvs)] |> head()
```

This thresholding can be used in RefSeq visualization.
Filter words using ORA threshold and frequency threshold by setting `ora=TRUE`.

```{r oranet, warning=FALSE, message=FALSE, cache=TRUE}
net <- wcGeneSummary(inpSymbol, plotType="network",
                     ora=TRUE, edgeLink=FALSE)
net@net
```

# Custom usage

## Recluster the cluster using word information

```{r textclus, warning=FALSE, message=FALSE}
simExample <- returnSim(returnExample()$color,
                        keyType="ENSEMBL", argList=list(ora=TRUE))
heatmap(simExample)
```

## Interactive inspection of Bayesian network annotated by words

In this example, a Bayesian network showing the module eigengenes relationship are inferred using `boot.strength` function in `bnlearn` from the weighted gene correlation network analysis (WGCNA) results. The modules are annotated by word clouds produced by `wcGeneSummary()`, and can be exported to the format of `Cytoscape.js` or `vis.js`. In this way, module relationship can be interactively inspected with the functional implications.

```{r mod, warning=FALSE, message=FALSE}
## In this example, we simulate WGCNA results.
## you can just use results from WGCNA.
## Assuming WGCNA results are stored in `mod`
mod <- wcGeneSummary::returnExample()
MEs <- mod$MEs
modColors <- mod$colors
ensg <- names(modColors)

# library(bnlearn)
library(igraph)

## Replace like boot.strength(mod$MEs, R=500, algorithm = "hc")
# dag <- model2network("[ME1][ME2|ME1]") # If using bnlearn
dag <- graph_from_literal( ME1-+ME2, ME1-+ME3 )

## Convert to igraph
# g <- as.igraph(dag)
g <- dag

## Assign edge attributes
## Skip, if you perform boot.strength, the edge attributes can be added from the result
# el <- data.frame(as_edgelist(g))
# colnames(el) <- c("from","to")
# el <- left_join(el, bs)
# E(g)$strength <- el$strength
# E(g)$direction <- el$direction

## Node attributes
V(g)$stripName <- gsub("ME","",V(g)$name)
sizes <- table(modColors)
V(g)$size <- as.numeric(sizes[V(g)$stripName])

## Directory to save images and a script
rootDir <- "./"
netDir <- "visCyjs"
imageDir <- "images"

dir.create(paste0(rootDir, netDir))
dir.create(paste0(rootDir, netDir, "/", imageDir))

images <- c()
plotType <- "bar"
numLim <- 200 # limit for gene number
for (i in V(g)$name){
    print(i)
    i <- as.numeric(gsub("ME","",i)) # strip ME

    queries <- ensg[modColors==i]
    if (length(queries)>numLim) {
        warning("Sampling random genes")
        queries <- queries[sample(1:length(queries), numLim)] ## Temporary restrict to randomly chosen genes, should be replaced to like kME values
    }
    
    ## Convert to ENTREZ
    entre <- AnnotationDbi::select(org.Hs.eg.db, keytype="ENSEMBL",
        keys = queries, columns = "ENTREZID")$ENTREZID
    
    if (plotType=="bar"){
        plt <- makeBar(entre, keyType="ENTREZID") # get barplot
    } else { ## If wordcloud
        # A <- wcGeneSummary(entre,
        #                    madeUpper=c("dna","rna",
        #                                tolower(keys(org.Hs.eg.db, keytype="SYMBOL"))))
        # palNum <- sample(1:151,1) # palettetown
        # 
        # ## This time use ggwordcloud()
        # plt <- ggwordcloud::ggwordcloud(A$df$word, A$df$freq,
        #                      shape="circle", min.freq = 10,
        #                      rot.per = 0.5, random.order = FALSE,
        #                      colors = pokepal(palNum))+
        #          scale_size_area(max_size = 40)
    }
    ## Save images
    ggsave(paste0(rootDir, netDir, "/", imageDir, "/", i ,".png"),
           plt, dpi=300, width=10, height=10)
    ## Store image dir
    images <- c(images, paste0(imageDir, "/", i ,".png"))
}
V(g)$image <- images

## Node shape
if (plotType=="bar"){
    V(g)$shape <- rep("rectangle", length(V(g))) 
} else {
    V(g)$shape <- rep("circle", length(V(g)))
}

## Scale the node size
sizeMin <- 50
sizeMax <- 200
rawMin <- min(V(g)$size)
rawMax <- max(V(g)$size)
scf <- (sizeMax-sizeMin)/(rawMax-rawMin)
V(g)$size <- scf * V(g)$size + sizeMin - scf * rawMin

## Export
exportCyjs(g, rootDir, netDir)
# or, exportVisjs(g, rootDir, netDir)
```

Use like `http-server` in the directory containing a exported JavaScript, and interactively inspect the module relationship with word information.

The example visualization is shown below (not by the code above).

![Example visualization of a Bayesian network](https://github.com/noriakis/software/blob/main/images/wcbn.png?raw=true)

## Annotating module eigengenes dendrogram

The relationship between gene clusters are often investigated in clustering analysis like WGCNA. As users of WGCNA typically plot dendrogram and heatmap of module eigengenes using `plotEigengeneNetworks`, it is useful to combine with wcGeneSummary, which plot additional word information on a dendrogram with one line.

```{r wgcna, warning=FALSE, message=FALSE, cache=TRUE, fig.width=6, fig.height=9}
# WGCNA::plotEigengeneNetworks(mod$MEs, mod$colors, plotHeatmaps = FALSE)
plotEigengeneNetworksWithWords(MEs, modColors)
```

For examining enriched pathway names in the dendrograms, specify `argList` to `wcGeneSummary`, like `list(enrich="kegg")`.

```{r wgcnapath, warning=FALSE, message=FALSE, cache=TRUE, fig.width=6, fig.height=9}
plotEigengeneNetworksWithWords(MEs, modColors, type="words", argList=list(enrich="kegg"))
```


Other than textual information, we can simply annotate the dendrogram using enrichment analysis.
Useful for inspecting how the branches of dendrogram contains pathway information.

```{r wgcna2, warning=FALSE, message=FALSE, cache=TRUE, fig.width=6, fig.height=9}
plotEigengeneNetworksWithWords(MEs, modColors, type="enrich")
```

## Assess the occurrence of the speicific words across gene clusters

```{r findterm, fig.height=5, fig.width=5, cache=TRUE}
library(limma)
library(ggrepel)
query <- "DNA repair"
tab <- getGeneKEGGLinks(species="hsa")
listOfGenes <- list()
for (path in unique(tab$PathwayID)){
    listOfGenes[[path]] <- subset(tab, PathwayID==path)$GeneID
}
## Random subset! The results would be different.
frq <- findTerm(query, listOfGenes[sample(length(listOfGenes), 20)],
                split=TRUE,
                keyType="ENTREZID")
plt <- data.frame(t(data.frame(frq, check.names=FALSE)),
                  check.names=FALSE)

plt$name <- gsub("path:", "", rownames(plt))
p <- ggplot(plt, aes(dna, repair, label = plt[,3])) +
    geom_point(color = "red")+ 
    geom_text_repel(bg.color="white")+theme_minimal()+
    xlab("dna")+ylab("repair")
p
```

```{r}
sessionInfo()
```