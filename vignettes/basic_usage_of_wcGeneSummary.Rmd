---
title: "wcGeneSummary"
author: "Noriaki Sato"
package: wcGeneSummary
output: 
    BiocStyle::html_document:
        toc_float: true
vignette: >
    %\VignetteIndexEntry{wcGeneSummary}
    %\VignetteEngine{knitr::knitr}
    %\VignetteEncoding{UTF-8}  
---

This package aims to visualize the word and text information contained in the gene or the other omics identifiers such as microbiome, and identify important words among the clusters, and compare the clusters based on those information. It contributes to understanding the gene clusters and aid in easy interpretation and visualization.

# Basic usage

Load the package and the database for converting identifiers.
In this example, we use mostly human-derived data, and use `org.Hs.eg.db`.

```{r load, warning=FALSE, message=FALSE}
library(wcGeneSummary)
library(org.Hs.eg.db)
library(ggplot2)
library(ggraph)
library(RColorBrewer)
library(ReactomePA)
library(clusterProfiler)
```

## Producing word clouds

We use ERCC genes as input. The basic usage of the package is producing a word cloud of gene summaries by querying gene IDs, default to symbol. The other type can be set by `keyType`. As many of the words are commonly observed, you should limit word frequency by `excludeFreq`, which is default to 2000. TF-IDF on the all the summary is precomputed, and `excludeTfIdf` can be specified too.

```{r basic, warning=FALSE, message=FALSE, cache=TRUE, fig.height=8, fig.width=8}
## Configure input genes
inpSymbol <- c("ERCC1","ERCC2","ERCC3","ERCC4","ERCC5","ERCC6","ERCC8")
gwc <- wcGeneSummary(inpSymbol)
gwc@wc
```

It accepts values of the `wordcloud()` function. `numWords` specifies how many words are to be shown on word cloud. The words are ordered by their frequency, and the subset of 1:`numWords` is used to downstream visualization.

```{r basic2, warning=FALSE, message=FALSE, cache=TRUE, fig.height=8, fig.width=8}
## Use palette from palettetown, palettetown::pokepal(150) (Mewtwo!)
gwc <- wcGeneSummary(inpSymbol, random.order=FALSE,
                     numWords=100,
                     excludeTfIdf = 150,
                     colors=palette(),
                     rot.per=0.4)
gwc@wc
```

It also returns a data frame consisting of frequency of each term.

```{r table, cache=TRUE}
knitr::kable(
  head(gwc@freqDf), caption = 'Term frequencies.',
  row.names = FALSE
)
```

N-gram is supported by library `tm`, specified by `ngram`.
Default is `1`, and the example specifying `2` is shown below.

```{r ngramwc, warning=FALSE, fig.height=8, fig.width=8, cache=TRUE}
gwc2 <- wcGeneSummary(inpSymbol, ngram=2, numWords=50)
gwc2@wc
```

Using `clusterProfiler` functions, one can use enriched pathway names for visualization.
The `enrich` option can be specified for `'kegg'` or `'reactome'`, this time we specify `'reactome'`.

```{r ngrampath, warning=FALSE, fig.height=8, fig.width=8, cache=TRUE}
gwc3 <- wcGeneSummary(inpSymbol, enrich="reactome", tfidf=TRUE, numWords=50)
gwc3@wc
```

One of the main questions is which words can be clustered together among the words contained in the queried gene cluster. Word clustering (`pvclust`) and identified significant clusters based on the occurrence in the text can be visualized by specifying `tag=TRUE`. For the significance threshold, `pvclAlpha` can be specified. The default parameters perform `pvclust` on the subset of dataset for words with high frequency specified by `numWords`. If one want to perform on whole matrix (which is a natural way), `tagWhole=TRUE` can be specified, although it is computationally intensive.

```{r tagging, warning=FALSE, cache=TRUE, fig.height=8, fig.width=8}

pal <- brewer.pal(4, "PuOr") 
pal <- colorRampPalette(pal)(20)


## Cluster on subset of words
gwcl <- wcGeneSummary(inpSymbol,
                     numWords=30,
                     tag=TRUE,
                     pal = pal,
                     rot.per=0.4)
gwcl@wc
gwcl@pvpick

## Cluster on whole matrix

gwclWhole <- wcGeneSummary(inpSymbol,
                     numWords=50,
                     tag=TRUE, tagWhole=TRUE,
                     pal = pal,
                     cl=snow::makeCluster(8),
                     rot.per=0.4)
gwclWhole@wc
gwclWhole@pvpick
```

In this example showing ERCC genes, the term `DNA repair` is clustered as expected.

## Producing correlation networks

The next main function is producing correlation networks between words based on the co-occurrence of the words in the text.

```{r basic3, warning=FALSE, message=FALSE, cache=TRUE, fig.height=8, fig.width=8}
net <- wcGeneSummary(inpSymbol, plotType="network")
net@net
```

The edge label corresponding to correlation values can be shown by `edgeLabel=TRUE`. The number of words to be shown on plot can be specified by `numWords`. The threshold of correlation can be specified by `corThresh`. The text color can be changed by `colorText=TRUE`. The type of edge can be specified by `edgeLink`, which is by default `TRUE` (link will be used).

```{r ngramnet, warning=FALSE, message=FALSE, cache=T, fig.height=8, fig.width=8}
net <- wcGeneSummary(inpSymbol, plotType="network",
                     edgeLabel=TRUE, corThresh=0.5,
                     numWords=20, colorText=TRUE)
net@net
```

The clustering results based on `pvclust` can be shown also on the correlation network, by the node color (`tag=TRUE`).

```{r tagnet, warning=FALSE, message=FALSE, cache=T, fig.height=8, fig.width=8}
net <- wcGeneSummary(inpSymbol, plotType="network", corThresh=0.2,
                     numWords=20, tag=TRUE)
net@net
net@pvpick
```

The genes associated with the corresponding words can be shown by specifying `genePlot=TRUE`, useful for assessing which words is associated with interesting genes. The edges connecting words to corresponding genes are shown.
Additionally, one can specify `genePlotNum` for limiting the genes shown, which can be useful for identifying important genes associated with high-frequent words.

```{r gplot, warning=FALSE, message=FALSE, cache=TRUE, fig.height=8, fig.width=8}
net <- wcGeneSummary(inpSymbol, plotType="network",
                     genePlot=TRUE, corThresh=0.5,
                     tag=TRUE, edgeLink=FALSE,
                     numWords=20)
net@net
```

The associated enriched pathways (if present) can be shown by specifying `genePathPlot`, using `ggforce`.
In this option, the function first performs over-representation analysis on the whole gene set, and plot enriched terms for included genes in the plot. Enrichment analysis here is performed by the library `clusterProfiler` or `ReactomePA`, and one can control which pathways to plot by `genePathPlotSig` value.

```{r gpplot, warning=FALSE, message=FALSE, cache=TRUE, fig.width=8, fig.height=8}
library(concaveman)
library(ggforce)
net <- wcGeneSummary(inpSymbol, plotType="network",
                     genePathPlot="reactome", corThresh=0.5,
                     tag=TRUE, edgeLink=FALSE,
                     genePathPlotSig=0.05, numWords=20)

net@net
```


## Visualization of PubMed information.

Using `rentrez`, one can perform the same analysis on PubMed text like the article title and abstract. The function queries for the input gene symbols (or microbes) and visualize. For typical use cases, the genes identified by showing `genePlot`, or hub genes identified in gene network analysis can be queried.

```{r wcabst_wc, cache=FALSE, fig.height=8, fig.width=8}
ab <- wcAbst(inpSymbol[1:3], retMax=20)
ab@wc
```

As fetching the same information is not desirable and time consuming, the same object can be passed to `redo` option and re-perform the analysis like tagging, or changing the visualization options.

```{r wcabst_wc_2, cache=TRUE, fig.height=8, fig.width=8}
pal <- brewer.pal(5, "PuOr") 
abtag <- wcAbst(redo=ab, tag=TRUE,
                cl=snow::makeCluster(10), pal=pal)
abtag2 <- wcAbst(redo=abtag, tag=TRUE, genePlot=TRUE,
                 plotType="network", corThresh=0.2, preset=TRUE)
abtag@wc
abtag2@net
```


## Comparing two or more networks

One can compare two or more networks by providing list of objects produced by wc* functions, like `wcGeneSummary` and `wcAbst`. This can be useful for assessing the similarity and dissimilarity of the various text sources, like PubMed, RefSeq, and Reactome pathway names.

```{r compare, cache=TRUE, fig.height=12, fig.width=12}
cxcls <- c()
for (i in c(1,2,3,5,6,8,9,10,11,12,13,14,16)){
    cxcls <- c(cxcls, paste0("CXCL",i))
}

net1 <- wcGeneSummary(inpSymbol, plotType="network",
                      corThresh=0.5, numWords=20)
net2 <- wcGeneSummary(cxcls, plotType="network",
                      corThresh=0.5, numWords=20)
net3 <- wcAbst(redo=ab, plotType="network",
               corThresh=0.2, numWords=20)

## Not having meaningful overlaps
compareWordNet(list(net1, net2),
               titles=c("ercc","cxcl"))
compareWordNet(list(net1, net3),
               titles=c("ercc","ercc-PubMed"))
compareWordNet(list(net1, net2, net3),
               titles=c("ercc","cxcl", "ercc-PubMed"))
```

If `tag` information is available in both gene clusters, combined tags can be visualized by `tag=TRUE`.

```{r tagcomp, cache=TRUE, fig.height=12, fig.width=15}
keggPathways <- org.Hs.egPATH2EG
mappedKeys <- mappedkeys(keggPathways)
keggList <- as.list(keggPathways[mappedKeys])

net1 <- wcGeneSummary(keggList$`04110`,
                      keyType="ENTREZID",
                      plotType="network",
                      corThresh=0.3,
                      numWords=30,
                      tag=TRUE,
                      tfidf=TRUE)

net2 <- wcGeneSummary(keggList$`04210`,
                      keyType="ENTREZID",
                      plotType="network",
                      corThresh=0.3,
                      numWords=30,
                      tfidf=TRUE,
                      tag=TRUE)

compareWordNet(list(net1, net2), tag=TRUE)
```

## Query words across clusters

## Text over represenatation analysis (experimental)

```{r ora}
geneList <- keggList$`00785` # Lipoic acid metabolism
pvs <- textORA(geneList)
hist(pvs)
pvs[order(pvs)] |> head()

geneList <- keggList$`05150` # Staphylococcus aureus infection
pvs <- textORA(geneList)
hist(pvs)
pvs[order(pvs)] |> head()
```

This thresholding can be used in RefSeq visualization.
Filter words using ORA threshold and frequency threshold by setting `ora=TRUE`.

```{r oranet, warning=FALSE, message=FALSE, cache=TRUE}
net <- wcGeneSummary(inpSymbol, plotType="network",
                     ora=TRUE, edgeLink=FALSE)
net@net
```

# Custom usage

## Recluster the cluster using word information

```{r textclus, warning=FALSE, message=FALSE}
simExample <- returnSim(returnExample()$color,
                        keyType="ENSEMBL", ora=TRUE)
heatmap(simExample)
```

## Interactive inspection of Bayesian network annotated by words

In this example, a Bayesian network showing the module eigengenes relationship are inferred using `boot.strength` function in `bnlearn` from the weighted gene correlation network analysis (WGCNA) results. The modules are annotated by word clouds produced by `wcGeneSummary()`, and can be exported to the format of `Cytoscape.js` or `vis.js`. In this way, module relationship can be interactively inspected with the functional implications.

```{r mod, warning=FALSE, message=FALSE}
## In this example, we simulate WGCNA results.
## you can just use results from WGCNA.
## Assuming WGCNA results are stored in `mod`
mod <- wcGeneSummary::returnExample()
MEs <- mod$MEs
modColors <- mod$colors
ensg <- names(modColors)

# library(bnlearn)
library(igraph)

## Replace like boot.strength(mod$MEs, R=500, algorithm = "hc")
# dag <- model2network("[ME1][ME2|ME1]") # If using bnlearn
dag <- graph_from_literal( ME1-+ME2, ME1-+ME3 )

## Convert to igraph
# g <- as.igraph(dag)
g <- dag

## Assign edge attributes
## Skip, if you perform boot.strength, the edge attributes can be added from the result
# el <- data.frame(as_edgelist(g))
# colnames(el) <- c("from","to")
# el <- left_join(el, bs)
# E(g)$strength <- el$strength
# E(g)$direction <- el$direction

## Node attributes
V(g)$stripName <- gsub("ME","",V(g)$name)
sizes <- table(modColors)
V(g)$size <- as.numeric(sizes[V(g)$stripName])

## Directory to save images and a script
rootDir <- "./"
netDir <- "visCyjs"
imageDir <- "images"

dir.create(paste0(rootDir, netDir))
dir.create(paste0(rootDir, netDir, "/", imageDir))

images <- c()
plotType <- "bar"
numLim <- 200 # limit for gene number
for (i in V(g)$name){
    print(i)
    i <- as.numeric(gsub("ME","",i)) # strip ME

    queries <- ensg[modColors==i]
    if (length(queries)>numLim) {
        warning("Sampling random genes")
        queries <- queries[sample(1:length(queries), numLim)] ## Temporary restrict to randomly chosen genes, should be replaced to like kME values
    }
    
    ## Convert to ENTREZ
    entre <- AnnotationDbi::select(org.Hs.eg.db, keytype="ENSEMBL",
        keys = queries, columns = "ENTREZID")$ENTREZID
    
    if (plotType=="bar"){
        plt <- makeBar(entre, keyType="ENTREZID") # get barplot
    } else { ## If wordcloud
        # A <- wcGeneSummary(entre,
        #                    madeUpper=c("dna","rna",
        #                                tolower(keys(org.Hs.eg.db, keytype="SYMBOL"))))
        # palNum <- sample(1:151,1) # palettetown
        # 
        # ## This time use ggwordcloud()
        # plt <- ggwordcloud::ggwordcloud(A$df$word, A$df$freq,
        #                      shape="circle", min.freq = 10,
        #                      rot.per = 0.5, random.order = FALSE,
        #                      colors = pokepal(palNum))+
        #          scale_size_area(max_size = 40)
    }
    ## Save images
    ggsave(paste0(rootDir, netDir, "/", imageDir, "/", i ,".png"),
           plt, dpi=300, width=10, height=10)
    ## Store image dir
    images <- c(images, paste0(imageDir, "/", i ,".png"))
}
V(g)$image <- images

## Node shape
if (plotType=="bar"){
    V(g)$shape <- rep("rectangle", length(V(g))) 
} else {
    V(g)$shape <- rep("circle", length(V(g)))
}

## Scale the node size
sizeMin <- 50
sizeMax <- 200
rawMin <- min(V(g)$size)
rawMax <- max(V(g)$size)
scf <- (sizeMax-sizeMin)/(rawMax-rawMin)
V(g)$size <- scf * V(g)$size + sizeMin - scf * rawMin

## Export
exportCyjs(g, rootDir, netDir)
# or, exportVisjs(g, rootDir, netDir)
```

Use like `http-server` in the directory containing a exported JavaScript, and interactively inspect the module relationship with word information.

The example visualization is shown below (not by the code above).

![Example visualization of a Bayesian network](https://github.com/noriakis/software/blob/main/images/wcbn.png?raw=true)

## Annotating module eigengenes dendrogram

As users of WGCNA typically plot dendrogramm and heatmap of module eigengenes using `plotEigengeneNetworks`, it is useful to combine with wcGeneSummary, which plot additional word information on a dendrogram with one line.

```{r wgcna, warning=FALSE, message=FALSE, cache=TRUE, fig.width=6, fig.height=9}
# WGCNA::plotEigengeneNetworks(mod$MEs, mod$colors, plotHeatmaps = FALSE)
plotEigengeneNetworksWithWords(MEs, modColors)
```

## Assess the occurrence of the speicific words across gene clusters

```{r findterm, fig.height=5, fig.width=5, cache=TRUE}
library(limma)
library(ggrepel)
query <- "DNA repair"
tab <- getGeneKEGGLinks(species="hsa")
listOfGenes <- list()
for (path in unique(tab$PathwayID)){
    listOfGenes[[path]] <- subset(tab, PathwayID==path)$GeneID
}
frq <- findTerm(query, listOfGenes[sample(length(listOfGenes), 20)],
                split=TRUE,
                keyType="ENTREZID")
plt <- data.frame(t(data.frame(frq, check.names=FALSE)),
                  check.names=FALSE)

plt$name <- gsub("path:", "", rownames(plt))
p <- ggplot(plt, aes(dna, repair, label = plt[,3])) +
    geom_point(color = "red")+ 
    geom_text_repel(bg.color="white")+theme_minimal()+
    xlab("dna")+ylab("repair")
p
```

# Application examples

We demonstrate an use case, which investigates transcriptomic changes induced by BK polyomavirus (BKPyV) infection in renal proximal tubular epithelial cells ([Assetta et al. 2016](https://pubmed.ncbi.nlm.nih.gov/27381292/)). Differentially expressed mRNAs in 3 days post-infection were obtained, and down-regulated mRNAs in BKPyV infected cells were examined.

## Load the necessary packages and genes

```{r load2, warning=FALSE, message=FALSE}
library(wcGeneSummary)
library(org.Hs.eg.db)
library(ggplot2)
library(ReactomePA);library(clusterProfiler)
library(ggraph)
degs <- wcGeneSummary:::d3degDownAn2019
length(degs)
degs
```

## Enrichment analysis

First, we perform enrichment analysis using ReactomePA.
From the enrichment analysis results, the cluster is related to transcriptional regulation by TP53.

```{r ea, warning=FALSE, message=FALSE, cache=TRUE}
## Convert to ENTREZID
entre <- AnnotationDbi::select(org.Hs.eg.db, keytype="SYMBOL",
                               keys = degs, columns = "ENTREZID")$ENTREZID
pway <- setReadable(enrichPathway(entre), org.Hs.eg.db)
sigpway <- subset(pway@result, p.adjust<0.05)
sigpway$Description
cnetplot(pway)

## Genes involved in significant pathways
unlist(unique(sapply(sigpway$geneID, function (x) strsplit(x,"/"))))
```

We store the name of enriched pathways in the network for the downstream analysis.

```{r netenrich, cache=FALSE}
netreac <- wcGeneSummary(degs,
                         enrich="reactome",
                         plotType="network",
                         numWords=50,
                         colorText=TRUE)
```

## Text mining the gene summaries
Next we perform the plain function producing a correlation network, with showing the top-genes related to high-frequency words in the text in RefSeq summary. We obtained the list of these genes from geneCount slot.

```{r basic2app, warning=FALSE, message=FALSE, cache=TRUE, fig.width=10, fig.height=10}
net1 <- wcGeneSummary(degs,
                      plotType="network",
                      colorText=TRUE,
                      numWords=30,
                      corThresh=0.4,
                      genePlot=TRUE,
                      genePlotNum=5,
                      edgeLink=FALSE,
                      genePathPlot="reactome")
net1@net
net1@geneCount
top <- names(net1@geneCount[net1@geneCount>=6])
top
```

## Text mining the available literature

These genes are further queried for PubMed information.
First, show the network for the article titles.

```{r absttitleapp, fig.height=9, fig.width=9}
titlenet <- wcAbst(top,
                   target="title",
                   plotType="network",
                   colorText=TRUE,
                   corThresh=0.2,
                   preset=TRUE,
                   retMax=50,
                   numWords=50,
                   edgeLink=FALSE)
titlenet@net
```

Obtain and show the network for the article abstract.

```{r abstmainapp, fig.height=9, fig.width=9}
abstnet <- wcAbst(top,
                  target="abstract",
                  plotType="network",
                  colorText=TRUE,
                  corThresh=0.2,
                  preset=TRUE,
                  numWords=50,
                  retMax=50,
                  edgeLink=FALSE)
abstnet@net
```

## Combine and compare networks

From the RefSeq summary and articles related to important genes, the cluster could have functionality of DNA damage response, which is also upregulated by BKPyV infection. These networks can be combined to find intersections and differences. We can see that in addition to Reactome pathway names, plenty of information could be obtained and summarized by querying other databases, which could aid in interpreting clusters of genes and hypothesis generation.

```{r combineapp, cache=F, fig.height=20, fig.width=20}
compareWordNet(list(abstnet, titlenet, netreac, net1),
               titles=c("Abstract","Title","Reactome","RefSeq"))
```

From the network, DNA damage repair pathway, especially nucleotide excision repair related to DDB2, BAP1,and RAD17 might be related to BKPyV infection, which cannot be prioritize based on log2FoldChange or enrichment analysis.

```{r ddr, cache=T}
conet <- compareWordNet(list(netreac,
                    net1,
                    titlenet,
                    abstnet),
               returnNet = TRUE)

ddrRelated <- induced.subgraph(conet,
                 names(V(conet)) %in% c(names(neighbors(conet, "DNA")),
                                    names(neighbors(conet, "damage")),
                                    names(neighbors(conet, "repair"))))
V(ddrRelated)$SYMBOL <- names(V(ddrRelated)) %in% keys(org.Hs.eg.db,"SYMBOL")
ggraph(ddrRelated)+
    geom_edge_diagonal2()+
    geom_node_point(aes(color=SYMBOL))+
    geom_node_text(aes(label=name, color=SYMBOL),check_overlap=TRUE, repel=TRUE,
                   bg.color = "white", segment.color="black",
                   bg.r = .15)+
    scale_color_manual(values=c("steelblue","tomato"))+
    theme_graph()
```


The network can be obtained by `returnNet=TRUE`, which can be used for downstream analysis like assessment of degrees and community detection.

```{r combineNet, cache=F, fig.height=10, fig.width=10}

conetDeg <- igraph::degree(conet)
conetDeg[order(conetDeg, decreasing=TRUE)] |> head(15)

conet <- induced_subgraph(conet, conetDeg>1)

wt <- igraph::walktrap.community(conet)
igraph::V(conet)$walktrap <- wt$membership
pal <- RColorBrewer::brewer.pal(length(unique(wt$membership)),
                                "Dark2") 
pal <- colorRampPalette(pal)(20)

ggraph(conet)+
    geom_edge_link()+
    geom_node_point(aes(color=factor(walktrap)), size=3)+
    geom_node_text(aes(label=name, color=factor(walktrap)),
                   check_overlap=TRUE, repel=TRUE,
                   bg.color = "white", segment.color="black",
                   bg.r = .15)+
    scale_color_manual(values=pal,
                         name="Walktrap")+
    theme_graph()
```

Dynamic layout can be also used to compare the networks, by `graphlayouts`, for comparing the multiple graphs, especially useful for time-series analysis. See the documentation of [`layout_as_dynamic`](http://graphlayouts.schochastics.net/reference/layout_dynamic.html) for specifying the alpha, which is default to 0.5. 

```{r dyn, warning=FALSE, fig.height=8, fig.width=15}
library(igraph)
dyn <- plotDynamic(list(abstnet, titlenet), concat="intersection",
                   titles=c("Abstract","Title"), alpha=0.8)
dyn
```


```{r}
sessionInfo()
```